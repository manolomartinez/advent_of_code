a â† â€¢Import "../../../Project Euler/aux.bqn"
m â† â€¢Import "/home/manolo/Software/BQN_cosas/bqn-libs/matrix.bqn"

Parse â† {
  l1â€¿l2â€¿l3 â† âˆ¾Â´((â‹ˆâŠ‘)â‹ˆ((Â¯1âŠ¸â†“â‹ˆÂ¯1âŠ¸âŠ‘)1âŠ¸â†“))ğ•©
  l1â†©'#'âŠ¸=Â¨('.'âŠ¸=âˆ¨'#'âŠ¸=)âŠ¸/l1
  l2â†©(â†•âˆ˜â‰ l1)âŠ¸âˆŠÂ¨(a.StrtoNatÂ¨',' a.Split('('âŠ¸â‰ âˆ§')'âŠ¸â‰ )âŠ¸/)Â¨ l2
  l3â†©a.StrtoNatÂ¨',' a.Split('{'âŠ¸â‰ âˆ§'}'âŠ¸â‰ )âŠ¸/ l3
  l1â€¿l2â€¿l3
}

machines â† ParseÂ¨ ' 'âŠ¸a.SplitÂ¨ â€¢FLines "./input.txt" 
#machines â† ParseÂ¨ ' 'âŠ¸a.SplitÂ¨ â€¢FLines "./test.txt" 

Doable â† {
  ğ•¨ğ•Šl1â€¿l2â€¿l3:
  âˆ¨Â´(ğ•¨ <Ë˜âˆ˜a.Combinations â‰ l2){l1â‰¡2|+Â´ğ•¨âŠğ•©}Â¨<l2 
}

â€¢Show +Â´{ğ•Šm:1âŠ¸+â€¢_while_ {Â¬ğ•© Doable m} 1}Â¨ machines # part 1

# For part 2 we need to look into the minimum number of presses to get each
# joltage value.
# Take for example {60,61,248,220,221,242,246}
# Here we need to use combos that contain 0 60 times, combos that contain 1 61
# times, etc.
# This seems to point to a system of equations: 
# The combos for that line are (0,1,4,5,6) (1,4,6) (0,1,2,5) (1,2,3) (0,2,3,5,6) (0,1,3,6) (2,3,4,5,6) (0,1,2,4,5,6)
# lets call the variables for the combes c0, c1, .. c7, so:
# c0 + c2 + c4 + c5 + c7 = 60
# c0 + c1 + c2 + c3 + c5 + c7 = 61
# etc.
# And there's an extra equation that we can use to calculate the minimum. We
# start with the maximum joltaje j and say
# c0 + ... + c7 = j
# and if there is no all-natural-numbers inverse we move on to j+1, etc


#âŒˆÂ´âŒŠÂ´Â¨ 2âŠ¸âŠ‘Â¨ machines
#âŒˆÂ´â‰ Â¨ 1âŠ¸âŠ‘Â¨ machines
#
# Bell number
{âŠ‘(+`âŠ¢Â´âŠ¸âˆ¾)âŸğ•©â¥Š1} 3
# Like a restricted Bell number
# 1 1 1 1
# 1 2 3 4
# 1 3 6 10
# 1 4 10 20

Pnâ†{
#  number of partitions of ğ•© of size ğ•¨
  Â¯1âŠ¸âŠ‘(+`âŠ¢)âŸ(ğ•¨-1)(ğ•©+1)/â‹ˆ1
}

pahash â† âŸ¨âŸ¨1,1âŸ©âŸ© â€¢HashMap â‹ˆâ‹ˆ1
Paâ†{
  pahash.Has ğ•¨â€¿ğ•©?pahash.Get ğ•¨â€¿ğ•©;
  #  Actual partitions of ğ•© of size ğ•¨
  1ğ•Šğ•©: 1â€¿ğ•© pahash.Set â‹ˆâ‹ˆğ•©â‹„pahash.Get 1â€¿ğ•©;
  ğ•¨â€¿ğ•© pahash.Set âˆ¾Â´{(âŠ‘ğ•©)âŠ¸âˆ¾Â¨1âŠ¸âŠ‘ğ•©}Â¨((ğ•©âŠ¸-)â‹ˆÂ¨((ğ•¨-1)âŠ¸ğ•ŠÂ¨))(â†•ğ•©+1)
  pahash.Get ğ•¨â€¿ğ•© 
}


Pa_oldâ†{
  #  Actual partitions of ğ•© of size ğ•¨
    1ğ•Šğ•©:â‹ˆâ‹ˆğ•©;
    âˆ¾Â´{(âŠ‘ğ•©)âŠ¸âˆ¾Â¨1âŠ¸âŠ‘ğ•©}Â¨((ğ•©âŠ¸-)â‹ˆÂ¨((ğ•¨-1)âŠ¸ğ•ŠÂ¨))(â†•ğ•©+1)
}

1 Pa 1
sumhash â† âŸ¨1âŸ© â€¢HashMap âŸ¨â‹ˆâ‹ˆ1âŸ©
WaystoSum_aux â† {
  S 1:â‹ˆâ‹ˆ1;
  ways â† {(ğ•©âŠ¸-â‹ˆâŠ¢)Â¨1+â†•âŒŠÃ·âŸœ2ğ•©}ğ•©
  ğ•© sumhash.Set âˆ¾Â´âŸ¨â‹ˆâ‹ˆğ•©âŸ©âˆ¾{aâ€¿bâ† ğ•©â‹„â¥Š(sumhash.Get a)âˆ¾âŒœsumhash.Get b}Â¨ways
  sumhash.Get ğ•©
  }
WaystoSum â‡ {âˆ§â·âˆ§Â¨Â¯1âŠ¸âŠ‘ WaystoSum_auxÂ¨1âŠ¸+âˆ˜â†• ğ•©}


â‰  5 Pa 7

l1â€¿l2â€¿l3 â† âŠ‘machines
l2
l3
â‰>l2
#+Â´ l3 m.MP (m.Inverse >l2) 
#(â†•â‰ l3)âŠ¸âˆŠË˜ >l2 


{l1â€¿l2â€¿l3 â† ğ•©â‹„(+Â´Ë˜â‰>l2)PnÂ¨l3}Â¨machines
âŒŠÂ´{l1â€¿l2â€¿l3 â† ğ•©â‹„âŒŠÂ´l3}Â¨machines


Step â† {
# Step gets a list of previous button pushes, an l2 and l3; and returns a list
# of lists, were each member is a list of button pushes, a new l2 and a new l2
  ğ•ŠâŸ¨âŸ©:âŸ¨âŸ©;
  ğ•Špâ€¿âŸ¨âŸ©â€¿âŸ¨0âŸ©:â‹ˆğ•©;
  ğ•©
  pâ€¿l2â€¿l3 â† ğ•©
  l2 (0<l3)âŠ¸/Â¨â†©
  l3 (0<âŠ¢)âŠ¸/â†©
  # n the number to match
  # c for candidates, the buttons that can contribute
  câ†{(â†•â‰ l2)/Ëœğ•©âŠ¸âŠ‘Â¨l2} nâ†âŠ‘â‹(+Â´Ë˜â‰>l2)PnÂ¨l3
  m â† âŒŠÂ´Â¨l2 /Â¨ <l3 # max button presses per button
  bâ†(â‰ c)Pa((nâŠ‘l3)âŒˆnâŠ‘m) # button presses
  l3s â† (<l3) -Â¨ +Â´Â¨b Ã—Â¨ <c âŠ l2
  f â† âˆ§Â´Â¨0âŠ¸â‰¤Â¨ l3s ((â†•â‰ l3)â‰ âŒœn)âŠ¸/Â¨ â†©
  l2 (âˆ§Â´Ë˜(â†•â‰ l2)â‰ âŒœc)âŠ¸/â†©
  l2 ((â†•â‰ l3)â‰ âŒœn)âŠ¸/Â¨ â†©
  l3s (âˆ§Â´Â¨0âŠ¸=Â¨(0âŠ¸=Â¨+Â´l2)âŠ¸/Â¨l3s)âŠ¸/â†©
  {fâŠ¸/ âˆ¾Â´Â¨((<p)+Â¨+Â´Â¨b)â‹ˆÂ¨(<l2)â‹ˆÂ¨ğ•©}âŠâŸ¨âŸ© l3s
}

machines2 â† {ğ•ŠÂ·â€¿l2â€¿l3: â‹ˆ0â€¿l2â€¿l3}Â¨machines
Step 0â€¿l2â€¿l3
((â†•â‰ l3)â‰ 6)

Combs â† {l2â€¿l3 â† ğ•©â‹„âŠ‘â‹(<+Â´Ë˜â‰>l2)PnÂ¨l3}

Step2 â† {
# Step gets a list of previous button pushes, an l2 and a list of l3; and
# returns a list of lists, were each member is a list of button pushes, a new l2
# and a new list of l3s
  #ğ•ŠâŸ¨âŸ©:âŸ¨âŸ©;
  #ğ•Špâ€¿âŸ¨âŸ©â€¿âŸ¨0âŸ©:â‹ˆğ•©;
  pâ€¿l2â€¿l3 â† ğ•©
  #l2 (0<l3)âŠ¸/Â¨â†©
  â€¢Show l3 (âˆ¨Â´0<âŠ¢)âŠ¸/Â¨â†©
  # n the number to match
  # c for candidates, the buttons that can contribute
  câ†{(â†•â‰ l2)/Ëœğ•©âŠ¸âŠ‘Â¨l2} nâ†âŠ‘â‹(+Â´Ë˜â‰>l2)PnÂ¨âŠ‘l3
  #câ†{(â†•â‰ l2)/Ëœğ•©âŠ¸âŠ‘Â¨l2} nâ†{âŠ‘â‹+Â´Ë˜â‰>ğ•©}l2
  bâ†(â‰ c)Pa(nâŠ‘âŠ‘l3) # button presses
  l3s â† âˆ¾Â´{(<ğ•©)-Â¨+Â´Â¨bÃ—Â¨<câŠl2}Â¨ l3
  #f â† âˆ§Â´Â¨0âŠ¸â‰¤Â¨ l3s((â†•âˆ˜â‰ âŠ‘l3)â‰ n)âŠ¸/Â¨ â†©
  l3s((â†•âˆ˜â‰ âŠ‘l3)â‰ n)âŠ¸/Â¨ â†©
  l2(âˆ§Â´Ë˜(â†•â‰ l2)â‰ âŒœc)âŠ¸/â†©
  â€¢Show l2 ((â†•â‰ âŠ‘l3)â‰ n)âŠ¸/Â¨ â†©
  â€¢Show l3s (âˆ§Â´Â¨0âŠ¸=Â¨(0âŠ¸=Â¨+Â´l2)âŠ¸/Â¨l3s)âŠ¸/â†©
  â€¢Show l3s (âˆ¨Â´0<âŠ¢)âŠ¸/Â¨ â†©
  #l3s (0=â‰ l3s)â—¶âŸ¨l3s,â‹ˆ"none"âŸ© â†©
  #{âˆ¾âŠ¸/ âˆ¾Â´Â¨((<p)+Â¨+Â´Â¨b)â‹ˆÂ¨(<l2)â‹ˆÂ¨ğ•©}âŠâŸ¨âŸ© l3s
  âˆ¾Â´Â¨(nâŠ‘âŠ‘l3)â‹ˆÂ¨(<l2)â‹ˆÂ¨{ğ•©âŠ”ËœâŠCombs l2â€¿ğ•©}l3s
}



#machines2 â† {ğ•ŠÂ·â€¿l2â€¿l3: â‹ˆ0â€¿l2â€¿l3}Â¨machines
#{âŒŠÂ´âŠ‘Â¨(âˆ¾Â´Step2Â¨)â€¢_while_{âˆ¨Â´0âŠ¸â‰ â‰ Â¨1âŠ¸âŠ‘Â¨ğ•©}ğ•©}Â¨ machines2
l2

#(âˆ¾Â´StepÂ¨)â€¢_while â‹ˆ0â€¿l2â€¿l3


Step3 â† {
  # Step gets an "object" (list). In this object there id: 
  # * p: A number of previous button pushes 
  # * l2: A list of button codes
  # * l3s: A iist of lists of joltages
  # It râ‹ˆturns a list of objects of the same kind.
  ğ•ŠÂ·â€¿âŸ¨âŸ©â€¿Â·:ğ•©;
  pâ€¿l2â€¿l3s â† â€¢Show ğ•©
  # We first choose one member of l3, the one with the most zeros, no negatives,
  # and the smallest other numbers
  #â€¢Show l3 â† {ğ•©/Ëœâ€¢Show(âŒŠÂ´=âŠ¢)â€¢Show +Â´Â¨ğ•©}{ğ•©/Ëœ(âŒˆÂ´=âŠ¢)+Â´Â¨(0âŠ¸=)Â¨ğ•©}(âˆ§Â´0âŠ¸â‰¤)Â¨âŠ¸/l3s
  l3 â† âŠ‘l3s/Ëœ(âŒˆÂ´=âŠ¢) +Â´Â¨0âŠ¸=Â¨l3s # Which members of any l3 are zero?
  z â† /0âŠ¸=l3 # Which members of any l3 are zero?
  # n the number to match
  # c for candidates, the buttons that can contribute
  â€¢Show câ†{(â†•â‰ l2)/Ëœğ•©âŠ¸âŠ‘Â¨l2} â€¢Show nâ†âŠ‘(Â¬âˆ˜âˆŠ)âŸœzâŠ¸/â‹(+Â´Ë˜â‰>l2)PnÂ¨â€¢Show l3
  bâ†(â‰ c)Pa(nâŠ‘l3) # button presses
  l3n â† âˆ¾Â´{(<ğ•©)-Â¨+Â´Â¨b Ã—Â¨<câŠl2}Â¨l3s # the new l3s
  l2 (âˆ§Â´Ë˜(â†•â‰ l2)â‰ âŒœc)âŠ¸/â†©
  âŸ¨p++Â´âŠ‘b,l2,l3nâŸ©
}

Pick â† {
  # Pick the best l3 to follow
  l2â€¿l3 â† ğ•©
  zâ†0â‰¤âŠ‘l3 # Which members of any l3 are positive?
  m â† âŒŠÂ´ âˆ¾Â´ c â†{(+Â´Ë˜â‰>l2)PnÂ¨ğ•©}Â¨l3 # c for counts, m for minima
}

Regroup â† {
  ğ•ŠÂ·â€¿âŸ¨âŸ©â€¿Â·:ğ•©;
  ğ•Špâ€¿l2â€¿l3:
  l3 (âˆ§Â´0âŠ¸â‰¤)Â¨âŠ¸/ â†©
  l3sâ†l3âŠ”ËœâŠ{Combs l2â€¿ğ•©}Â¨l3
  {pâ€¿l2â€¿ğ•©}Â¨l3s
}



{Step3â€¢_while_{0âŠ¸â‰ â‰ 1âŠ¸âŠ‘ğ•©}ğ•©}Â¨ machines2


Replace â† {bğ•Ša:âŒŠÂ´a{ğ•¨âŒ¾(ğ•©âŠ¸âŠ‘)(â‰ b)/â‹ˆâˆ}Â¨(â†•â‰ b)/Ëœb}
((â‹â‰ Â¨)âŠâŠ¢)
Compatible â† âˆ§Â´(=âˆ¨{(âˆâŠ¸=ğ•¨)âˆ¨(âˆâŠ¸=ğ•©)})Â¨
Compose â† {â·(0âŠ¸â‰ â‰ )Â¨âŠ¸/âˆ¾Â´<Ë˜ğ•¨(Compatibleâ—¶âŸ¨âŸ¨âŸ©,(=â—¶âŒŠâ€¿âŠ¢)Â¨âŸ©)âŒœğ•©}
Calc â† {
  Â·â€¿l2â€¿l3â†ğ•©
  âŒŠÂ´+Â´Â¨ComposeÂ´ ((â’â‰ Â¨)âŠâŠ¢)(<Ë˜â‰>l2){ğ•¨âŠ¸ReplaceÂ¨ğ•©}Â¨(+Â´Ë˜â‰>l2)PaÂ¨l3
}


# Possible presses per joltage
(<Ë˜â‰>l2){ğ•¨âŠ¸ReplaceÂ¨ğ•©}Â¨(+Â´Ë˜â‰>l2)PaÂ¨l3
